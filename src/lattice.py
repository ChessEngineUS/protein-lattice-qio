"""\nLattice model definitions for protein folding simulations.\n\nImplements 2D square and 3D cubic lattices with self-avoiding walk constraints.\n"""\n\nfrom abc import ABC, abstractmethod\nfrom typing import List, Tuple\nimport numpy as np\n\n\nclass Lattice(ABC):\n    """Abstract base class for lattice models."""\n    \n    @abstractmethod\n    def get_neighbors(self, coord: Tuple[int, ...]) -> List[Tuple[int, ...]:]:\n        """Get valid neighboring positions on the lattice."""\n        pass\n    \n    @abstractmethod\n    def get_dimensions(self) -> int:\n        """Return the dimensionality of the lattice."""\n        pass\n    \n    def is_valid_conformation(self, coords: np.ndarray) -> bool:\n        """\n        Check if a conformation is valid (self-avoiding).\n        \n        Args:\n            coords: Array of shape (N, D) where N is sequence length, D is dimensions\n            \n        Returns:\n            True if conformation is self-avoiding, False otherwise\n        """\n        # Check for duplicate coordinates (self-intersection)\n        unique_coords = set(map(tuple, coords))\n        return len(unique_coords) == len(coords)\n    \n    def calculate_contacts(self, coords: np.ndarray, sequence: str) -> List[Tuple[int, int]]:\n        """\n        Calculate non-local contacts in a conformation.\n        \n        A contact is defined as two non-consecutive residues that are adjacent\n        on the lattice.\n        \n        Args:\n            coords: Array of shape (N, D) with conformation coordinates\n            sequence: Protein sequence string\n            \n        Returns:\n            List of (i, j) tuples representing contacts where i < j\n        """\n        contacts = []\n        n = len(coords)\n        \n        for i in range(n):\n            for j in range(i + 2, n):  # Skip consecutive residues\n                distance = np.sum(np.abs(coords[i] - coords[j]))\n                if distance == 1:  # Adjacent on lattice\n                    contacts.append((i, j))\n        \n        return contacts\n\n\nclass SquareLattice2D(Lattice):\n    """2D square lattice with 4-connectivity."""\n    \n    def get_neighbors(self, coord: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """Get 4-connected neighbors on 2D square lattice."""\n        x, y = coord\n        return [\n            (x + 1, y),\n            (x - 1, y),\n            (x, y + 1),\n            (x, y - 1),\n        ]\n    \n    def get_dimensions(self) -> int:\n        return 2\n\n\nclass CubicLattice3D(Lattice):\n    """3D cubic lattice with 6-connectivity."""\n    \n    def get_neighbors(self, coord: Tuple[int, int, int]) -> List[Tuple[int, int, int]]:\n        """Get 6-connected neighbors on 3D cubic lattice."""\n        x, y, z = coord\n        return [\n            (x + 1, y, z),\n            (x - 1, y, z),\n            (x, y + 1, z),\n            (x, y - 1, z),\n            (x, y, z + 1),\n            (x, y, z - 1),\n        ]\n    \n    def get_dimensions(self) -> int:\n        return 3\n